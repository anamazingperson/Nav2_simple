[TOC]
# 项目目标
移动机器人自主导航系统
验收标准（流程和大致项目跑通+可以改用自己导航的算法）TurtleBot3机器人了解，对应的关节和连杆，导航需要的传感器怎么设置 
1.	内置导航nav2实现全局导航，可以采用内置算法，导航的流程实现，可以采用开源的项目，流程一定要会。
2.	比如流程里有建图，需要建图
3. 里面对应的功能，里面的话题，服务，动作分别是什么作用。

# 项目实战
# 理论基础
## 机器人介绍
优势：开源的、应用广，资料多。
![alt text](image-2.png)
### 介绍
TurtleBot3 是一款非常受欢迎的移动机器人平台，广泛应用于教育、研究和开发领域。它有多个型号，包括 Burger、Waffle 和 Waffle Pi。以下是关于 TurtleBot3 的详细描述，包括传感器、车轮、外形等关键特性：
- **传感器**：激光雷达、IMU 和可选摄像头。
- **车轮**：差分驱动系统，配备两个驱动轮。
- **外形**：Burger 为圆形底座，Waffle/Waffle Pi 为矩形底座。
- **控制器**：树莓派 3 Model B 或 B+。
- **电池**：锂离子电池，续航时间适中。
- **扩展性**：多个接口用于额外硬件。
- **开源**：硬件和软件完全开源。
- **ROS 兼容性**：非常适合基于 ROS 的项目。

这些特性使 TurtleBot3 适用于从教育项目到机器人研究的广泛应用场景。
里程计是什么，对应的数据类型，主要是一个传感器，获取物体的位姿，应用有可视化（rviz）、方便导航和定位。数据一般都是通过话题来发布
## Nav2包框架介绍

![alt text](image.png)
# Nav2 tutorial
1. 基本的导航案例，给定初始位置，以及目标位置，机器人可以过去
```bash
ros2 launch nav2_bringup tb3_simulation_launch.py headless:=False
```
2. 学习navigation2导航包源码怎么入手，先看什么文件比较好，主要是想快速学习怎么使用这个导航包完成自己的任务。是先看param里面得yaml文件，了解怎么配置吗

### Nav2 bringup工具包
#### 文件结构
```plaint
├── CHANGELOG.rst
├── CMakeLists.txt
├── launch
│   ├── bringup_launch.py
│   ├── cloned_multi_tb3_simulation_launch.py
│   ├── localization_launch.py
│   ├── navigation_launch.py
│   ├── rviz_launch.py
│   ├── slam_launch.py
│   ├── tb3_simulation_launch.py
│   └── unique_multi_tb3_simulation_launch.py
├── maps
│   ├── turtlebot3_world.pgm
│   └── turtlebot3_world.yaml
├── package.xml
├── params
│   ├── nav2_multirobot_params_1.yaml
│   ├── nav2_multirobot_params_2.yaml
│   ├── nav2_multirobot_params_all.yaml
│   └── nav2_params.yaml
├── README.md
├── rviz
│   ├── nav2_default_view.rviz
│   └── nav2_namespaced_view.rviz
├── urdf
│   └── turtlebot3_waffle.urdf
└── worlds
    ├── waffle.model
    └── world_only.model
```
## 自主移动机器人导航框架
```plantuml
@startmindmap
* 导航的流程实现
** 感知
*** 传感器数据怎么设置
*** SLAM建图
** 规划
*** 内置的算法
** 控制
*** 跟踪目标轨迹
@endmindmap
```

## 涉及到的核心知识
1. 机器人替换。基于上述现成的，替换成自己机器人，首先将urdf替换为自己的移动机器人，确保有base_link。符合一些标准的坐标系要有，map,odom.
还有就是params里面的物体的半径需要和urdf对应起来，这个是机器人避障算法的关键参数。可以找开源的常用机器人。[open source mobile robot urdf](https://github.com/ali-pahlevani/Mobile_Robot_URDF_Maker)
2. 地图替换类似。地图生成采用。地图的获取可以采用，slam-toolbox来实现扫图。得到地图数据之后可以采用下述方法保存文件。
```bash
sudo apt install ros-$ROS_DISTRO-nav2-map-server
ros2 run nav2_map_server map_saver_cli --help
```
得到ngm文件和yaml文件
3. 修改各种算法，导航算法、控制算法..内置的算法。通过修改condig/nav2_params.yaml实现，里面有规划的控制的插件（插件是实现某一任务的额外的插件）。实现各种算法都已网上查找插件实现。
```yaml
global_planner:
  plugin: "nav2_navfn_planner/NavfnPlanner"
```
4. 以及自己编写的算法可以嵌入。
可以，通过编写一个插件实现。插件本质上是一个功能包，相当于写一个功能包，采用c++/python都可以实现。nav2_navfn_planner/NavfnPlanner，，上述的前半部分是包名，后半部分是一个类，继承标准的导航类：nav2_core.global_planner.GlobalPlanner。还需要修改一些依赖，来声明这个包是个插件，具体的插件创建可以查看官网。
5. 采用python api来实现设置目标点，和加入视觉算法来自主得到目标点。[python接口学习](https://docs.nav2.org/commander_api/index.html),,按照对应的接口熟悉各函数的应用。
6. 导航中的几个模块分别对应bringup里面的哪些函数，还是nav2中的哪些函数，bringup是基于nav2实现的吗、
bringup是一个例子告诉如何使用nav2 包的，里面用到nav2包的有yaml文件和launch文件。
```plantuml
@startmindmap
* 自定义导航包
** 复制bringup的config/*.yaml,修改机器人的尺寸等
** 编写launch文件
*** 1.加载地图（nav2_map_server）
*** 2.定位（nav2_amcl）
*** 3.全局路径规划（nav2_plan_server）
*** 4.局部路径规划和控制（nav2_controller）
*** 5.恢复，遇到异常恢复（nav2_recoveries_server）
*** 6.管理上述过程（nav2_bt_server）
*** 7.巡航功能（nav2_waypoint_follower）
*** 8.节点生产周期管理（nav2_lifecycle_manager）
@endmindmap
```
7. 查看Bringup运行时有哪些通讯起作用。里面对应的功能，里面的话题，服务，动作分别是什么作用。
```plantuml
@startyaml
Communication Channels:
  Topics:
    - /tf:
      - Purpose: Publishes the transform tree (relationships between coordinate frames).
      - Nodes Involved: robot_state_publisher, tf2_ros, and other transform publishers.
    - /tf_static:
      - Purpose: Publishes static transforms.
      - Nodes Involved: robot_state_publisher.
    - /map:
      - Purpose: Publishes the static map of the environment.
      - Nodes Involved: map_server.
    - /scan:
      - Purpose: Publishes sensor data (e.g., laser scan data).
      - Nodes Involved: Sensor drivers (e.g., hokuyo_node).
    - /odom:
      - Purpose: Publishes odometry data (robot's estimated position and orientation).
      - Nodes Involved: Odometry nodes (e.g., robot_localization).
    - /global_costmap:
      - Purpose: Publishes the global costmap used for path planning.
      - Nodes Involved: global_costmap node.
    - /local_costmap:
      - Purpose: Publishes the local costmap used for obstacle avoidance.
      - Nodes Involved: local_costmap node.
    - /nav2_msgs/Path:
      - Purpose: Publishes the global and local paths generated by the planners.
      - Nodes Involved: planner_server, controller_server.

  Services:
    - /get_map:
      - Purpose: Requests the static map from the map_server.
      - Nodes Involved: map_server.
    - /get_plan:
      - Purpose: Requests a global plan from the planner_server.
      - Nodes Involved: planner_server.
    - /clear_costmaps:
      - Purpose: Clears the costmaps to remove old obstacles.
      - Nodes Involved: global_costmap, local_costmap nodes.
    - /set_initial_pose:
      - Purpose: Sets the initial pose of the robot for localization.
      - Nodes Involved: amcl.

  Actions:
    - /navigate_to_pose:
      - Purpose: Sends a navigation goal to the bt_navigator.
      - Nodes Involved: bt_navigator.
    - /follow_waypoints:
      - Purpose: Sends a sequence of waypoints to the waypoint_follower.
      - Nodes Involved: waypoint_follower.
    - /spin:
      - Purpose: Makes the robot spin in place (used for localization).
      - Nodes Involved: controller_server.
    - /backup:
      - Purpose: Makes the robot move backward (used in recovery behaviors).
      - Nodes Involved: controller_server.
@endyaml
```
8. 怎么编写一个launch文件,函数使用
```plantuml
@startyaml
函数: 生成启动描述
LaunchDescription:
  - 包含启动动作
DeclareLaunchArgument:
  - 声明启动参数
LaunchConfiguration:
  - 引用启动参数
Node:
  - 启动一个 ROS 2 节点
@endyaml
```